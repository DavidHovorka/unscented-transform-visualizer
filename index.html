<!DOCTYPE html>
<html>
  <head>
    <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
  </head>
  <body>
    <div id="plot"></div>

    <label for="meanInput">Mean:</label>
    <input id="meanInput" type="text" value="0" placeholder="standard deviation" />
    <br>
    <br>
    <label for="standardDeviationInput">Standard Deviation:</label>
    <input id="standardDeviationInput" type="text" value="1" placeholder="standard deviation" />
    <br>
    <br>
    <label for="transformationFunctionInput">Transformation Function: y =</label>
    <input id="transformationFunctionInput" type="text" value="2 * x" placeholder="transformation function" />
    <br>
    <br>
    <label for="alphaInput">Alpha:</label>
    <input id="alphaInput" type="text" value="0.2" placeholder="alpha" />
    <br>
    <br>
    <label for="betaInput">Beta:</label>
    <input id="betaInput" type="text" value="2" placeholder="beta" />
    <br>
    <br>
    <label for="kappaInput">Kappa:</label>
    <input id="kappaInput" type="text" value="1" placeholder="kappa" />
    <br>
    <br>

    <button onclick="updatePlot()">Update</button>
    <script>

    const inputs = [
        document.getElementById("meanInput"),
        document.getElementById("standardDeviationInput"),
        document.getElementById("transformationFunctionInput"),
        document.getElementById("alphaInput"),
        document.getElementById("betaInput"),
        document.getElementById("kappaInput")
    ];
    //let mu = 1;
    //let standard_deviation = 1;


//    let gaussian_expression = "(1 / (standard_deviation * Math.sqrt(2 * Math.PI))) * Math.exp(-Math.pow(x - mu, 2) / (2 * standard_deviation * standard_deviation));"

    function updatePlot(){
        let mu = parseFloat(document.getElementById("meanInput").value);
        let standard_deviation = parseFloat(document.getElementById("standardDeviationInput").value);

        function generatePoints(expression, x_min, x_max, step){
        const x_points = [];
        const y_points = [];

        for (let x = x_min; x <= x_max; x += step){
            x_points.push(x);
            const val = eval(expression);
            y_points.push(val);
        }

        return [x_points, y_points]; // vracÃ­ pole
    }

    function drawCurve(x_points, y_points, name, color){
        Traces.push({
        x: x_points,
        y: y_points,
        mode: "lines",
        line: { color: color },
        name: name
      });
    }

    // Standard Normal variate using Box-Muller transform.
    function gaussianRandom(mean, stdev) {
        const u = 1 - Math.random(); // Converting [0,1) to (0,1]
        const v = Math.random();
        const z = Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
        // Transform to the desired mean and standard deviation:
        return z * stdev + mean;
    }

    function transformPoints(expression, x_points){
        for (let i = 0; i < x_points.length; i++){
            let x = x_points[i];
            x_points[i] = eval(expression);
        }
        return x_points;
    }

    let Traces = [];


    function generateGaussian(mean, std_dev, min_x, max_x, step){
            const x_points = [];
            const y_points = [];

            for (let x = min_x; x <= max_x; x += step){
                x_points.push(x);
                const y = (1 / (std_dev * Math.sqrt(2 * Math.PI))) * 
                          Math.exp(-Math.pow(x - mean, 2) / (2 * std_dev * std_dev));
                y_points.push(y);
            }

            return [x_points, y_points];
        }

    // Gaussian parameters; must be defined before generating gaussian points
    //let mu = 0; // mean
    //let standard_deviation = 1;
    //let [x_points, y_points] = generatePoints(gaussian_expression, -5, 5, 0.01);
    let [x_points, y_points] = generateGaussian(mu, standard_deviation, -5, 5, 0.01);
    drawCurve(x_points, y_points, "Original Gaussian", "green");

    // Transformation function
    // y = 2x
    let transformation_function = document.getElementById("transformationFunctionInput").value;//"2 * x";
    [x_points, y_points] = generatePoints(transformation_function, -5, 5, 0.01);
    drawCurve(x_points, y_points, "Transformation Function", "red")

    const graphLayout = {
        title: "Unscented transformation",
        xaxis: { title: "x",
            range: [-5, 5]
         },
        yaxis: { 
            title: "y",
            range: [-1, 1]
        }
      };

    // histogram
    var x = [];
    for (var i = 0; i < 50000; i++) {
        x[i] = gaussianRandom(mu, standard_deviation)//(Math.random() * 10) - 5;
    }

    
    x = transformPoints(transformation_function, x)

    Traces.push({
    x: x,
    type: 'histogram',
    histnorm: 'probability density',
    marker: { color: 'rgba(0,128,128,0.5)' },
    name: "Monte Carlo Approximation",
    opacity: 0.5
});

    function unscentedTransform(mean, standard_deviation, transformation_function){
        sigmas = [];
        sigmas[0] = mean;

        // generate sigma points
        // only 1D; L = 2n + 1
        let n = 1;
        let alpha = parseFloat(document.getElementById("alphaInput").value);
        let beta = parseFloat(document.getElementById("betaInput").value);
        let kappa = parseFloat(document.getElementById("kappaInput").value);
        
        let lambda = (alpha**2) * (n + kappa) - n;
        
        // Numerical stability check
        if (Math.abs(n + lambda) < 1e-10) {
            console.error("Numerically instable parameters! Try larger alpha or kappa.");
            return [mean, standard_deviation**2];
        }
        
        let spread = Math.sqrt((n + lambda) * (standard_deviation**2));
        sigmas[1] = mean + spread;
        sigmas[2] = mean - spread;
        
        // generate weights
        weights_mean = [];
        weights_covariance = [];
        weights_mean[0] = lambda / (n + lambda);
        weights_covariance[0] = (lambda / (n + lambda)) + (1 - alpha**2 + beta);

        for (let i = 1; i <= 2 * n; i++){
            let tmp = 1/(2 * (n + lambda));
            weights_mean[i] = tmp;
            weights_covariance[i] = tmp;
        }

        console.log("alpha:", alpha, "beta:", beta, "kappa:", kappa);
        console.log("lambda:", lambda);
        console.log("n + lambda:", n + lambda);
        console.log("weights_mean:", weights_mean);
        console.log("weights_covariance:", weights_covariance[0]);

        graphWeightedPoints(sigmas, [-0.1, -0.1, -0.1], weights_mean, 'Sigma Points', 'blue', 'red');

        let transformedSigmaPoints = [];
        let x = 0;
        for (let i = 0; i < 3; i++){
            x = sigmas[i];
            transformedSigmaPoints[i] = eval(transformation_function);
        }

        graphWeightedPoints(transformedSigmaPoints, [-0.3, -0.3, -0.3], weights_mean, 'Transformed Sigma Points', 'blue', 'red');

        let new_mean = 0;
        let new_covariance = 0;
        for(let i = 0; i < 2*n + 1; i++){
            new_mean += weights_mean[i] * transformedSigmaPoints[i];
        }
        for(let i = 0; i < 2*n + 1; i++){
            new_covariance += weights_covariance[i] * (transformedSigmaPoints[i] - new_mean)**2;
        }

        return [new_mean, new_covariance];
    }
    

    function graphWeightedPoints(x_points, y_points, weights, name, colorPositive, colorNegative){
        Traces.push({
        x: x_points,
        y: y_points,
        mode: 'markers',
        type: 'scatter',
        marker: {
        color: weights_mean.map(w => w >= 0 ? colorPositive : colorNegative),
        size: weights_mean.map(w => Math.abs(w) * 2),
        symbol: 'circle',
        },
        name: name
    });
    }

    function graphPoints(transformedPoints, y_points, name, color){
        Traces.push({
        x: transformedPoints,
        y: y_points,
        mode: 'markers',
        type: 'scatter',
        marker: {
            color: color,  
            size: 10,
            symbol: 'circle'
        },
        name: name
    });
    }

    let [new_mean, new_covariance] = unscentedTransform(mu, standard_deviation, transformation_function);

    let std_dev = Math.sqrt(new_covariance);
    let transformedPoints = [new_mean, new_mean - std_dev, new_mean + std_dev];

    graphPoints(transformedPoints, [-0.5, -0.5, -0.5] ,"Unscented Transformed", "orange");

    console.log(new_covariance);

    [x_points, y_points] = generateGaussian(new_mean, std_dev, -5, 5, 0.01);
    drawCurve(x_points, y_points, "Transformed Gaussian", "blue");

    Plotly.newPlot("plot", Traces, graphLayout);}
    updatePlot();
    
    let sum_wm = weights_mean.reduce((a, b) => a + b, 0);
    let sum_wc = weights_covariance.reduce((a, b) => a + b, 0);

    inputs.forEach(input => {
        input.addEventListener("input", updatePlot);
    });

    </script>
  </body>
</html>